Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> HEADER newline statement newline
Rule 2     programme -> statement newline
Rule 3     programme -> HEADER newline statement newline programme
Rule 4     programme -> statement newline programme
Rule 5     statement -> affectation
Rule 6     affectation -> SET_VARIABLE = expression
Rule 7     statement -> ECHO expression
Rule 8     expression -> GET_VARIABLE
Rule 9     expression -> FLOAT
Rule 10    expression -> INT
Rule 11    expression -> STRING
Rule 12    expression -> $ ( ( expression ADD_OP expression ) )
Rule 13    expression -> $ ( ( expression MUL_OP expression ) )
Rule 14    expression -> expression EQ_CMP expression
Rule 15    expression -> expression NE_CMP expression
Rule 16    expression -> expression LT_CMP expression
Rule 17    block -> statement newline
Rule 18    block -> statement newline block
Rule 19    statement -> IF [ expression ] newline THEN newline block FI
Rule 20    statement -> IF [ expression ] newline THEN newline block ELSE newline block FI
Rule 21    statement -> WHILE [ expression ] ; DO newline block DONE
Rule 22    statement -> UNTIL [ expression ] ; DO newline block DONE

Terminals, with rules where they appear

$                    : 12 13
(                    : 12 12 13 13
)                    : 12 12 13 13
;                    : 21 22
=                    : 6
ADD_OP               : 12
DO                   : 21 22
DONE                 : 21 22
ECHO                 : 7
ELSE                 : 20
EQ_CMP               : 14
FI                   : 19 20
FLOAT                : 9
GET_VARIABLE         : 8
HEADER               : 1 3
IF                   : 19 20
INT                  : 10
LT_CMP               : 16
MUL_OP               : 13
NE_CMP               : 15
SET_VARIABLE         : 6
STRING               : 11
THEN                 : 19 20
UNTIL                : 22
WHILE                : 21
[                    : 19 20 21 22
]                    : 19 20 21 22
error                : 
newline              : 1 1 2 3 3 4 17 18 19 19 20 20 20 21 22

Nonterminals, with rules where they appear

affectation          : 5
block                : 18 19 20 20 21 22
expression           : 6 7 12 12 13 13 14 14 15 15 16 16 19 20 21 22
programme            : 3 4 0
statement            : 1 2 3 4 17 18

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    programme                      shift and go to state 1
    statement                      shift and go to state 3
    affectation                    shift and go to state 4

state 1

    (0) S' -> programme .



state 2

    (1) programme -> HEADER . newline statement newline
    (3) programme -> HEADER . newline statement newline programme

    newline         shift and go to state 10


state 3

    (2) programme -> statement . newline
    (4) programme -> statement . newline programme

    newline         shift and go to state 11


state 4

    (5) statement -> affectation .

    newline         reduce using rule 5 (statement -> affectation .)


state 5

    (7) statement -> ECHO . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 12

state 6

    (19) statement -> IF . [ expression ] newline THEN newline block FI
    (20) statement -> IF . [ expression ] newline THEN newline block ELSE newline block FI

    [               shift and go to state 18


state 7

    (21) statement -> WHILE . [ expression ] ; DO newline block DONE

    [               shift and go to state 19


state 8

    (22) statement -> UNTIL . [ expression ] ; DO newline block DONE

    [               shift and go to state 20


state 9

    (6) affectation -> SET_VARIABLE . = expression

    =               shift and go to state 21


state 10

    (1) programme -> HEADER newline . statement newline
    (3) programme -> HEADER newline . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    statement                      shift and go to state 22
    affectation                    shift and go to state 4

state 11

    (2) programme -> statement newline .
    (4) programme -> statement newline . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 2 (programme -> statement newline .)
    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    statement                      shift and go to state 3
    programme                      shift and go to state 23
    affectation                    shift and go to state 4

state 12

    (7) statement -> ECHO expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    newline         reduce using rule 7 (statement -> ECHO expression .)
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 13

    (8) expression -> GET_VARIABLE .

    EQ_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    NE_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    LT_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    newline         reduce using rule 8 (expression -> GET_VARIABLE .)
    ]               reduce using rule 8 (expression -> GET_VARIABLE .)
    ADD_OP          reduce using rule 8 (expression -> GET_VARIABLE .)
    MUL_OP          reduce using rule 8 (expression -> GET_VARIABLE .)
    )               reduce using rule 8 (expression -> GET_VARIABLE .)


state 14

    (9) expression -> FLOAT .

    EQ_CMP          reduce using rule 9 (expression -> FLOAT .)
    NE_CMP          reduce using rule 9 (expression -> FLOAT .)
    LT_CMP          reduce using rule 9 (expression -> FLOAT .)
    newline         reduce using rule 9 (expression -> FLOAT .)
    ]               reduce using rule 9 (expression -> FLOAT .)
    ADD_OP          reduce using rule 9 (expression -> FLOAT .)
    MUL_OP          reduce using rule 9 (expression -> FLOAT .)
    )               reduce using rule 9 (expression -> FLOAT .)


state 15

    (10) expression -> INT .

    EQ_CMP          reduce using rule 10 (expression -> INT .)
    NE_CMP          reduce using rule 10 (expression -> INT .)
    LT_CMP          reduce using rule 10 (expression -> INT .)
    newline         reduce using rule 10 (expression -> INT .)
    ]               reduce using rule 10 (expression -> INT .)
    ADD_OP          reduce using rule 10 (expression -> INT .)
    MUL_OP          reduce using rule 10 (expression -> INT .)
    )               reduce using rule 10 (expression -> INT .)


state 16

    (11) expression -> STRING .

    EQ_CMP          reduce using rule 11 (expression -> STRING .)
    NE_CMP          reduce using rule 11 (expression -> STRING .)
    LT_CMP          reduce using rule 11 (expression -> STRING .)
    newline         reduce using rule 11 (expression -> STRING .)
    ]               reduce using rule 11 (expression -> STRING .)
    ADD_OP          reduce using rule 11 (expression -> STRING .)
    MUL_OP          reduce using rule 11 (expression -> STRING .)
    )               reduce using rule 11 (expression -> STRING .)


state 17

    (12) expression -> $ . ( ( expression ADD_OP expression ) )
    (13) expression -> $ . ( ( expression MUL_OP expression ) )

    (               shift and go to state 27


state 18

    (19) statement -> IF [ . expression ] newline THEN newline block FI
    (20) statement -> IF [ . expression ] newline THEN newline block ELSE newline block FI
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 28

state 19

    (21) statement -> WHILE [ . expression ] ; DO newline block DONE
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 29

state 20

    (22) statement -> UNTIL [ . expression ] ; DO newline block DONE
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 30

state 21

    (6) affectation -> SET_VARIABLE = . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 31

state 22

    (1) programme -> HEADER newline statement . newline
    (3) programme -> HEADER newline statement . newline programme

    newline         shift and go to state 32


state 23

    (4) programme -> statement newline programme .

    $end            reduce using rule 4 (programme -> statement newline programme .)


state 24

    (14) expression -> expression EQ_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 33

state 25

    (15) expression -> expression NE_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 34

state 26

    (16) expression -> expression LT_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 35

state 27

    (12) expression -> $ ( . ( expression ADD_OP expression ) )
    (13) expression -> $ ( . ( expression MUL_OP expression ) )

    (               shift and go to state 36


state 28

    (19) statement -> IF [ expression . ] newline THEN newline block FI
    (20) statement -> IF [ expression . ] newline THEN newline block ELSE newline block FI
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 37
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 29

    (21) statement -> WHILE [ expression . ] ; DO newline block DONE
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 38
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 30

    (22) statement -> UNTIL [ expression . ] ; DO newline block DONE
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 39
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 31

    (6) affectation -> SET_VARIABLE = expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    newline         reduce using rule 6 (affectation -> SET_VARIABLE = expression .)
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 32

    (1) programme -> HEADER newline statement newline .
    (3) programme -> HEADER newline statement newline . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 1 (programme -> HEADER newline statement newline .)
    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    statement                      shift and go to state 3
    programme                      shift and go to state 40
    affectation                    shift and go to state 4

state 33

    (14) expression -> expression EQ_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 14 (expression -> expression EQ_CMP expression .)
    ]               reduce using rule 14 (expression -> expression EQ_CMP expression .)
    ADD_OP          reduce using rule 14 (expression -> expression EQ_CMP expression .)
    MUL_OP          reduce using rule 14 (expression -> expression EQ_CMP expression .)
    )               reduce using rule 14 (expression -> expression EQ_CMP expression .)
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26

  ! EQ_CMP          [ reduce using rule 14 (expression -> expression EQ_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 14 (expression -> expression EQ_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 14 (expression -> expression EQ_CMP expression .) ]


state 34

    (15) expression -> expression NE_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 15 (expression -> expression NE_CMP expression .)
    ]               reduce using rule 15 (expression -> expression NE_CMP expression .)
    ADD_OP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    MUL_OP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    )               reduce using rule 15 (expression -> expression NE_CMP expression .)
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26

  ! EQ_CMP          [ reduce using rule 15 (expression -> expression NE_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 15 (expression -> expression NE_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 15 (expression -> expression NE_CMP expression .) ]


state 35

    (16) expression -> expression LT_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 16 (expression -> expression LT_CMP expression .)
    ]               reduce using rule 16 (expression -> expression LT_CMP expression .)
    ADD_OP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    MUL_OP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    )               reduce using rule 16 (expression -> expression LT_CMP expression .)
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26

  ! EQ_CMP          [ reduce using rule 16 (expression -> expression LT_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 16 (expression -> expression LT_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 16 (expression -> expression LT_CMP expression .) ]


state 36

    (12) expression -> $ ( ( . expression ADD_OP expression ) )
    (13) expression -> $ ( ( . expression MUL_OP expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 41

state 37

    (19) statement -> IF [ expression ] . newline THEN newline block FI
    (20) statement -> IF [ expression ] . newline THEN newline block ELSE newline block FI

    newline         shift and go to state 42


state 38

    (21) statement -> WHILE [ expression ] . ; DO newline block DONE

    ;               shift and go to state 43


state 39

    (22) statement -> UNTIL [ expression ] . ; DO newline block DONE

    ;               shift and go to state 44


state 40

    (3) programme -> HEADER newline statement newline programme .

    $end            reduce using rule 3 (programme -> HEADER newline statement newline programme .)


state 41

    (12) expression -> $ ( ( expression . ADD_OP expression ) )
    (13) expression -> $ ( ( expression . MUL_OP expression ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ADD_OP          shift and go to state 45
    MUL_OP          shift and go to state 46
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 42

    (19) statement -> IF [ expression ] newline . THEN newline block FI
    (20) statement -> IF [ expression ] newline . THEN newline block ELSE newline block FI

    THEN            shift and go to state 47


state 43

    (21) statement -> WHILE [ expression ] ; . DO newline block DONE

    DO              shift and go to state 48


state 44

    (22) statement -> UNTIL [ expression ] ; . DO newline block DONE

    DO              shift and go to state 49


state 45

    (12) expression -> $ ( ( expression ADD_OP . expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 50

state 46

    (13) expression -> $ ( ( expression MUL_OP . expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 13
    FLOAT           shift and go to state 14
    INT             shift and go to state 15
    STRING          shift and go to state 16
    $               shift and go to state 17

    expression                     shift and go to state 51

state 47

    (19) statement -> IF [ expression ] newline THEN . newline block FI
    (20) statement -> IF [ expression ] newline THEN . newline block ELSE newline block FI

    newline         shift and go to state 52


state 48

    (21) statement -> WHILE [ expression ] ; DO . newline block DONE

    newline         shift and go to state 53


state 49

    (22) statement -> UNTIL [ expression ] ; DO . newline block DONE

    newline         shift and go to state 54


state 50

    (12) expression -> $ ( ( expression ADD_OP expression . ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    )               shift and go to state 55
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 51

    (13) expression -> $ ( ( expression MUL_OP expression . ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    )               shift and go to state 56
    EQ_CMP          shift and go to state 24
    NE_CMP          shift and go to state 25
    LT_CMP          shift and go to state 26


state 52

    (19) statement -> IF [ expression ] newline THEN newline . block FI
    (20) statement -> IF [ expression ] newline THEN newline . block ELSE newline block FI
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    block                          shift and go to state 57
    statement                      shift and go to state 58
    affectation                    shift and go to state 4

state 53

    (21) statement -> WHILE [ expression ] ; DO newline . block DONE
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    block                          shift and go to state 59
    statement                      shift and go to state 58
    affectation                    shift and go to state 4

state 54

    (22) statement -> UNTIL [ expression ] ; DO newline . block DONE
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    block                          shift and go to state 60
    statement                      shift and go to state 58
    affectation                    shift and go to state 4

state 55

    (12) expression -> $ ( ( expression ADD_OP expression ) . )

    )               shift and go to state 61


state 56

    (13) expression -> $ ( ( expression MUL_OP expression ) . )

    )               shift and go to state 62


state 57

    (19) statement -> IF [ expression ] newline THEN newline block . FI
    (20) statement -> IF [ expression ] newline THEN newline block . ELSE newline block FI

    FI              shift and go to state 63
    ELSE            shift and go to state 64


state 58

    (17) block -> statement . newline
    (18) block -> statement . newline block

    newline         shift and go to state 65


state 59

    (21) statement -> WHILE [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 66


state 60

    (22) statement -> UNTIL [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 67


state 61

    (12) expression -> $ ( ( expression ADD_OP expression ) ) .

    EQ_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    NE_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    LT_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    newline         reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ]               reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ADD_OP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    MUL_OP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    )               reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)


state 62

    (13) expression -> $ ( ( expression MUL_OP expression ) ) .

    EQ_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    NE_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    LT_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    newline         reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ]               reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ADD_OP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    MUL_OP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    )               reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)


state 63

    (19) statement -> IF [ expression ] newline THEN newline block FI .

    newline         reduce using rule 19 (statement -> IF [ expression ] newline THEN newline block FI .)


state 64

    (20) statement -> IF [ expression ] newline THEN newline block ELSE . newline block FI

    newline         shift and go to state 68


state 65

    (17) block -> statement newline .
    (18) block -> statement newline . block
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    FI              reduce using rule 17 (block -> statement newline .)
    ELSE            reduce using rule 17 (block -> statement newline .)
    DONE            reduce using rule 17 (block -> statement newline .)
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    statement                      shift and go to state 58
    block                          shift and go to state 69
    affectation                    shift and go to state 4

state 66

    (21) statement -> WHILE [ expression ] ; DO newline block DONE .

    newline         reduce using rule 21 (statement -> WHILE [ expression ] ; DO newline block DONE .)


state 67

    (22) statement -> UNTIL [ expression ] ; DO newline block DONE .

    newline         reduce using rule 22 (statement -> UNTIL [ expression ] ; DO newline block DONE .)


state 68

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline . block FI
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    SET_VARIABLE    shift and go to state 9

    block                          shift and go to state 70
    statement                      shift and go to state 58
    affectation                    shift and go to state 4

state 69

    (18) block -> statement newline block .

    FI              reduce using rule 18 (block -> statement newline block .)
    ELSE            reduce using rule 18 (block -> statement newline block .)
    DONE            reduce using rule 18 (block -> statement newline block .)


state 70

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline block . FI

    FI              shift and go to state 71


state 71

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .

    newline         reduce using rule 20 (statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ_CMP in state 33 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 33 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 33 resolved as shift
WARNING: shift/reduce conflict for EQ_CMP in state 34 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 34 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 34 resolved as shift
WARNING: shift/reduce conflict for EQ_CMP in state 35 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 35 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 35 resolved as shift
