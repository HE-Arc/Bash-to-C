Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    HEADER

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement newline
Rule 2     programme -> statement newline programme
Rule 3     statement -> affectation
Rule 4     affectation -> SET_VARIABLE = expression
Rule 5     statement -> ECHO expression
Rule 6     expression -> GET_VARIABLE
Rule 7     expression -> FLOAT
Rule 8     expression -> INT
Rule 9     expression -> STRING
Rule 10    expression -> $ ( ( expression ADD_OP expression ) )
Rule 11    expression -> $ ( ( expression MUL_OP expression ) )

Terminals, with rules where they appear

$                    : 10 11
(                    : 10 10 11 11
)                    : 10 10 11 11
=                    : 4
ADD_OP               : 10
ECHO                 : 5
FLOAT                : 7
GET_VARIABLE         : 6
HEADER               : 
INT                  : 8
MUL_OP               : 11
SET_VARIABLE         : 4
STRING               : 9
error                : 
newline              : 1 2

Nonterminals, with rules where they appear

affectation          : 3
expression           : 4 5 10 10 11 11
programme            : 2 0
statement            : 1 2

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    SET_VARIABLE    shift and go to state 5

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    affectation                    shift and go to state 3

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . newline
    (2) programme -> statement . newline programme

    newline         shift and go to state 6


state 3

    (3) statement -> affectation .

    newline         reduce using rule 3 (statement -> affectation .)


state 4

    (5) statement -> ECHO . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )

    GET_VARIABLE    shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    STRING          shift and go to state 11
    $               shift and go to state 12

    expression                     shift and go to state 7

state 5

    (4) affectation -> SET_VARIABLE . = expression

    =               shift and go to state 13


state 6

    (1) programme -> statement newline .
    (2) programme -> statement newline . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (4) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 1 (programme -> statement newline .)
    ECHO            shift and go to state 4
    SET_VARIABLE    shift and go to state 5

    statement                      shift and go to state 2
    programme                      shift and go to state 14
    affectation                    shift and go to state 3

state 7

    (5) statement -> ECHO expression .

    newline         reduce using rule 5 (statement -> ECHO expression .)


state 8

    (6) expression -> GET_VARIABLE .

    newline         reduce using rule 6 (expression -> GET_VARIABLE .)
    ADD_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    MUL_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    )               reduce using rule 6 (expression -> GET_VARIABLE .)


state 9

    (7) expression -> FLOAT .

    newline         reduce using rule 7 (expression -> FLOAT .)
    ADD_OP          reduce using rule 7 (expression -> FLOAT .)
    MUL_OP          reduce using rule 7 (expression -> FLOAT .)
    )               reduce using rule 7 (expression -> FLOAT .)


state 10

    (8) expression -> INT .

    newline         reduce using rule 8 (expression -> INT .)
    ADD_OP          reduce using rule 8 (expression -> INT .)
    MUL_OP          reduce using rule 8 (expression -> INT .)
    )               reduce using rule 8 (expression -> INT .)


state 11

    (9) expression -> STRING .

    newline         reduce using rule 9 (expression -> STRING .)
    ADD_OP          reduce using rule 9 (expression -> STRING .)
    MUL_OP          reduce using rule 9 (expression -> STRING .)
    )               reduce using rule 9 (expression -> STRING .)


state 12

    (10) expression -> $ . ( ( expression ADD_OP expression ) )
    (11) expression -> $ . ( ( expression MUL_OP expression ) )

    (               shift and go to state 15


state 13

    (4) affectation -> SET_VARIABLE = . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )

    GET_VARIABLE    shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    STRING          shift and go to state 11
    $               shift and go to state 12

    expression                     shift and go to state 16

state 14

    (2) programme -> statement newline programme .

    $end            reduce using rule 2 (programme -> statement newline programme .)


state 15

    (10) expression -> $ ( . ( expression ADD_OP expression ) )
    (11) expression -> $ ( . ( expression MUL_OP expression ) )

    (               shift and go to state 17


state 16

    (4) affectation -> SET_VARIABLE = expression .

    newline         reduce using rule 4 (affectation -> SET_VARIABLE = expression .)


state 17

    (10) expression -> $ ( ( . expression ADD_OP expression ) )
    (11) expression -> $ ( ( . expression MUL_OP expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )

    GET_VARIABLE    shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    STRING          shift and go to state 11
    $               shift and go to state 12

    expression                     shift and go to state 18

state 18

    (10) expression -> $ ( ( expression . ADD_OP expression ) )
    (11) expression -> $ ( ( expression . MUL_OP expression ) )

    ADD_OP          shift and go to state 19
    MUL_OP          shift and go to state 20


state 19

    (10) expression -> $ ( ( expression ADD_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )

    GET_VARIABLE    shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    STRING          shift and go to state 11
    $               shift and go to state 12

    expression                     shift and go to state 21

state 20

    (11) expression -> $ ( ( expression MUL_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )

    GET_VARIABLE    shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    STRING          shift and go to state 11
    $               shift and go to state 12

    expression                     shift and go to state 22

state 21

    (10) expression -> $ ( ( expression ADD_OP expression . ) )

    )               shift and go to state 23


state 22

    (11) expression -> $ ( ( expression MUL_OP expression . ) )

    )               shift and go to state 24


state 23

    (10) expression -> $ ( ( expression ADD_OP expression ) . )

    )               shift and go to state 25


state 24

    (11) expression -> $ ( ( expression MUL_OP expression ) . )

    )               shift and go to state 26


state 25

    (10) expression -> $ ( ( expression ADD_OP expression ) ) .

    newline         reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ADD_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    MUL_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    )               reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)


state 26

    (11) expression -> $ ( ( expression MUL_OP expression ) ) .

    newline         reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ADD_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    MUL_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    )               reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)

