Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    HEADER

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement newline
Rule 2     programme -> statement newline programme
Rule 3     statement -> affectation
Rule 4     affectation -> SET_VARIABLE = expression
Rule 5     statement -> ECHO expression
Rule 6     expression -> GET_VARIABLE
Rule 7     expression -> FLOAT
Rule 8     expression -> INT
Rule 9     expression -> STRING
Rule 10    expression -> $ ( ( expression ADD_OP expression ) )
Rule 11    expression -> $ ( ( expression MUL_OP expression ) )
Rule 12    expression -> expression EQ_CMP expression
Rule 13    expression -> expression NE_CMP expression
Rule 14    block -> statement newline
Rule 15    block -> statement newline block
Rule 16    statement -> IF [ expression ] newline THEN newline block FI
Rule 17    statement -> IF [ expression ] newline THEN newline block ELSE newline block FI

Terminals, with rules where they appear

$                    : 10 11
(                    : 10 10 11 11
)                    : 10 10 11 11
=                    : 4
ADD_OP               : 10
ECHO                 : 5
ELSE                 : 17
EQ_CMP               : 12
FI                   : 16 17
FLOAT                : 7
GET_VARIABLE         : 6
HEADER               : 
IF                   : 16 17
INT                  : 8
MUL_OP               : 11
NE_CMP               : 13
SET_VARIABLE         : 4
STRING               : 9
THEN                 : 16 17
[                    : 16 17
]                    : 16 17
error                : 
newline              : 1 2 14 15 16 16 17 17 17

Nonterminals, with rules where they appear

affectation          : 3
block                : 15 16 17 17
expression           : 4 5 10 10 11 11 12 12 13 13 16 17
programme            : 2 0
statement            : 1 2 14 15

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (16) statement -> . IF [ expression ] newline THEN newline block FI
    (17) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    SET_VARIABLE    shift and go to state 6

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    affectation                    shift and go to state 3

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . newline
    (2) programme -> statement . newline programme

    newline         shift and go to state 7


state 3

    (3) statement -> affectation .

    newline         reduce using rule 3 (statement -> affectation .)


state 4

    (5) statement -> ECHO . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 8

state 5

    (16) statement -> IF . [ expression ] newline THEN newline block FI
    (17) statement -> IF . [ expression ] newline THEN newline block ELSE newline block FI

    [               shift and go to state 14


state 6

    (4) affectation -> SET_VARIABLE . = expression

    =               shift and go to state 15


state 7

    (1) programme -> statement newline .
    (2) programme -> statement newline . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (16) statement -> . IF [ expression ] newline THEN newline block FI
    (17) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (4) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 1 (programme -> statement newline .)
    ECHO            shift and go to state 4
    IF              shift and go to state 5
    SET_VARIABLE    shift and go to state 6

    statement                      shift and go to state 2
    programme                      shift and go to state 16
    affectation                    shift and go to state 3

state 8

    (5) statement -> ECHO expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    newline         reduce using rule 5 (statement -> ECHO expression .)
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 9

    (6) expression -> GET_VARIABLE .

    EQ_CMP          reduce using rule 6 (expression -> GET_VARIABLE .)
    NE_CMP          reduce using rule 6 (expression -> GET_VARIABLE .)
    newline         reduce using rule 6 (expression -> GET_VARIABLE .)
    ]               reduce using rule 6 (expression -> GET_VARIABLE .)
    ADD_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    MUL_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    )               reduce using rule 6 (expression -> GET_VARIABLE .)


state 10

    (7) expression -> FLOAT .

    EQ_CMP          reduce using rule 7 (expression -> FLOAT .)
    NE_CMP          reduce using rule 7 (expression -> FLOAT .)
    newline         reduce using rule 7 (expression -> FLOAT .)
    ]               reduce using rule 7 (expression -> FLOAT .)
    ADD_OP          reduce using rule 7 (expression -> FLOAT .)
    MUL_OP          reduce using rule 7 (expression -> FLOAT .)
    )               reduce using rule 7 (expression -> FLOAT .)


state 11

    (8) expression -> INT .

    EQ_CMP          reduce using rule 8 (expression -> INT .)
    NE_CMP          reduce using rule 8 (expression -> INT .)
    newline         reduce using rule 8 (expression -> INT .)
    ]               reduce using rule 8 (expression -> INT .)
    ADD_OP          reduce using rule 8 (expression -> INT .)
    MUL_OP          reduce using rule 8 (expression -> INT .)
    )               reduce using rule 8 (expression -> INT .)


state 12

    (9) expression -> STRING .

    EQ_CMP          reduce using rule 9 (expression -> STRING .)
    NE_CMP          reduce using rule 9 (expression -> STRING .)
    newline         reduce using rule 9 (expression -> STRING .)
    ]               reduce using rule 9 (expression -> STRING .)
    ADD_OP          reduce using rule 9 (expression -> STRING .)
    MUL_OP          reduce using rule 9 (expression -> STRING .)
    )               reduce using rule 9 (expression -> STRING .)


state 13

    (10) expression -> $ . ( ( expression ADD_OP expression ) )
    (11) expression -> $ . ( ( expression MUL_OP expression ) )

    (               shift and go to state 19


state 14

    (16) statement -> IF [ . expression ] newline THEN newline block FI
    (17) statement -> IF [ . expression ] newline THEN newline block ELSE newline block FI
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 20

state 15

    (4) affectation -> SET_VARIABLE = . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 21

state 16

    (2) programme -> statement newline programme .

    $end            reduce using rule 2 (programme -> statement newline programme .)


state 17

    (12) expression -> expression EQ_CMP . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 22

state 18

    (13) expression -> expression NE_CMP . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 23

state 19

    (10) expression -> $ ( . ( expression ADD_OP expression ) )
    (11) expression -> $ ( . ( expression MUL_OP expression ) )

    (               shift and go to state 24


state 20

    (16) statement -> IF [ expression . ] newline THEN newline block FI
    (17) statement -> IF [ expression . ] newline THEN newline block ELSE newline block FI
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    ]               shift and go to state 25
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 21

    (4) affectation -> SET_VARIABLE = expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    newline         reduce using rule 4 (affectation -> SET_VARIABLE = expression .)
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 22

    (12) expression -> expression EQ_CMP expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
    newline         reduce using rule 12 (expression -> expression EQ_CMP expression .)
    ]               reduce using rule 12 (expression -> expression EQ_CMP expression .)
    ADD_OP          reduce using rule 12 (expression -> expression EQ_CMP expression .)
    MUL_OP          reduce using rule 12 (expression -> expression EQ_CMP expression .)
    )               reduce using rule 12 (expression -> expression EQ_CMP expression .)
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18

  ! EQ_CMP          [ reduce using rule 12 (expression -> expression EQ_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 12 (expression -> expression EQ_CMP expression .) ]


state 23

    (13) expression -> expression NE_CMP expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
    newline         reduce using rule 13 (expression -> expression NE_CMP expression .)
    ]               reduce using rule 13 (expression -> expression NE_CMP expression .)
    ADD_OP          reduce using rule 13 (expression -> expression NE_CMP expression .)
    MUL_OP          reduce using rule 13 (expression -> expression NE_CMP expression .)
    )               reduce using rule 13 (expression -> expression NE_CMP expression .)
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18

  ! EQ_CMP          [ reduce using rule 13 (expression -> expression NE_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 13 (expression -> expression NE_CMP expression .) ]


state 24

    (10) expression -> $ ( ( . expression ADD_OP expression ) )
    (11) expression -> $ ( ( . expression MUL_OP expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 26

state 25

    (16) statement -> IF [ expression ] . newline THEN newline block FI
    (17) statement -> IF [ expression ] . newline THEN newline block ELSE newline block FI

    newline         shift and go to state 27


state 26

    (10) expression -> $ ( ( expression . ADD_OP expression ) )
    (11) expression -> $ ( ( expression . MUL_OP expression ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    ADD_OP          shift and go to state 28
    MUL_OP          shift and go to state 29
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 27

    (16) statement -> IF [ expression ] newline . THEN newline block FI
    (17) statement -> IF [ expression ] newline . THEN newline block ELSE newline block FI

    THEN            shift and go to state 30


state 28

    (10) expression -> $ ( ( expression ADD_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 31

state 29

    (11) expression -> $ ( ( expression MUL_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression

    GET_VARIABLE    shift and go to state 9
    FLOAT           shift and go to state 10
    INT             shift and go to state 11
    STRING          shift and go to state 12
    $               shift and go to state 13

    expression                     shift and go to state 32

state 30

    (16) statement -> IF [ expression ] newline THEN . newline block FI
    (17) statement -> IF [ expression ] newline THEN . newline block ELSE newline block FI

    newline         shift and go to state 33


state 31

    (10) expression -> $ ( ( expression ADD_OP expression . ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    )               shift and go to state 34
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 32

    (11) expression -> $ ( ( expression MUL_OP expression . ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression

    )               shift and go to state 35
    EQ_CMP          shift and go to state 17
    NE_CMP          shift and go to state 18


state 33

    (16) statement -> IF [ expression ] newline THEN newline . block FI
    (17) statement -> IF [ expression ] newline THEN newline . block ELSE newline block FI
    (14) block -> . statement newline
    (15) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (16) statement -> . IF [ expression ] newline THEN newline block FI
    (17) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    SET_VARIABLE    shift and go to state 6

    block                          shift and go to state 36
    statement                      shift and go to state 37
    affectation                    shift and go to state 3

state 34

    (10) expression -> $ ( ( expression ADD_OP expression ) . )

    )               shift and go to state 38


state 35

    (11) expression -> $ ( ( expression MUL_OP expression ) . )

    )               shift and go to state 39


state 36

    (16) statement -> IF [ expression ] newline THEN newline block . FI
    (17) statement -> IF [ expression ] newline THEN newline block . ELSE newline block FI

    FI              shift and go to state 40
    ELSE            shift and go to state 41


state 37

    (14) block -> statement . newline
    (15) block -> statement . newline block

    newline         shift and go to state 42


state 38

    (10) expression -> $ ( ( expression ADD_OP expression ) ) .

    EQ_CMP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    NE_CMP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    newline         reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ]               reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ADD_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    MUL_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    )               reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)


state 39

    (11) expression -> $ ( ( expression MUL_OP expression ) ) .

    EQ_CMP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    NE_CMP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    newline         reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ]               reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ADD_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    MUL_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    )               reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)


state 40

    (16) statement -> IF [ expression ] newline THEN newline block FI .

    newline         reduce using rule 16 (statement -> IF [ expression ] newline THEN newline block FI .)


state 41

    (17) statement -> IF [ expression ] newline THEN newline block ELSE . newline block FI

    newline         shift and go to state 43


state 42

    (14) block -> statement newline .
    (15) block -> statement newline . block
    (14) block -> . statement newline
    (15) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (16) statement -> . IF [ expression ] newline THEN newline block FI
    (17) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (4) affectation -> . SET_VARIABLE = expression

    FI              reduce using rule 14 (block -> statement newline .)
    ELSE            reduce using rule 14 (block -> statement newline .)
    ECHO            shift and go to state 4
    IF              shift and go to state 5
    SET_VARIABLE    shift and go to state 6

    statement                      shift and go to state 37
    block                          shift and go to state 44
    affectation                    shift and go to state 3

state 43

    (17) statement -> IF [ expression ] newline THEN newline block ELSE newline . block FI
    (14) block -> . statement newline
    (15) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (16) statement -> . IF [ expression ] newline THEN newline block FI
    (17) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    SET_VARIABLE    shift and go to state 6

    block                          shift and go to state 45
    statement                      shift and go to state 37
    affectation                    shift and go to state 3

state 44

    (15) block -> statement newline block .

    FI              reduce using rule 15 (block -> statement newline block .)
    ELSE            reduce using rule 15 (block -> statement newline block .)


state 45

    (17) statement -> IF [ expression ] newline THEN newline block ELSE newline block . FI

    FI              shift and go to state 46


state 46

    (17) statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .

    newline         reduce using rule 17 (statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ_CMP in state 22 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 22 resolved as shift
WARNING: shift/reduce conflict for EQ_CMP in state 23 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 23 resolved as shift
