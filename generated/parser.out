Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADD
    HEADER
    L_EVALUATE
    MUL
    R_EVALUATE

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement newline programme
Rule 3     statement -> declaration
Rule 4     statement -> echo
Rule 5     echo -> ECHO expression
Rule 6     expression -> INT
Rule 7     expression -> FLOAT
Rule 8     expression -> STRING
Rule 9     expression -> SEQUENCE
Rule 10    expression -> EVALUATE
Rule 11    declaration -> declare_int
Rule 12    declaration -> declare_float
Rule 13    declaration -> declare_string
Rule 14    declare_int -> SEQUENCE = INT
Rule 15    declare_float -> SEQUENCE = FLOAT
Rule 16    declare_string -> SEQUENCE = STRING

Terminals, with rules where they appear

=                    : 14 15 16
ADD                  : 
ECHO                 : 5
EVALUATE             : 10
FLOAT                : 7 15
HEADER               : 
INT                  : 6 14
L_EVALUATE           : 
MUL                  : 
R_EVALUATE           : 
SEQUENCE             : 9 14 15 16
STRING               : 8 16
error                : 
newline              : 2

Nonterminals, with rules where they appear

declaration          : 3
declare_float        : 12
declare_int          : 11
declare_string       : 13
echo                 : 4
expression           : 5
programme            : 2 0
statement            : 1 2

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement newline programme
    (3) statement -> . declaration
    (4) statement -> . echo
    (11) declaration -> . declare_int
    (12) declaration -> . declare_float
    (13) declaration -> . declare_string
    (5) echo -> . ECHO expression
    (14) declare_int -> . SEQUENCE = INT
    (15) declare_float -> . SEQUENCE = FLOAT
    (16) declare_string -> . SEQUENCE = STRING

    ECHO            shift and go to state 8
    SEQUENCE        shift and go to state 9

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    echo                           shift and go to state 4
    declare_int                    shift and go to state 5
    declare_float                  shift and go to state 6
    declare_string                 shift and go to state 7

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . newline programme

    $end            reduce using rule 1 (programme -> statement .)
    newline         shift and go to state 10


state 3

    (3) statement -> declaration .

    newline         reduce using rule 3 (statement -> declaration .)
    $end            reduce using rule 3 (statement -> declaration .)


state 4

    (4) statement -> echo .

    newline         reduce using rule 4 (statement -> echo .)
    $end            reduce using rule 4 (statement -> echo .)


state 5

    (11) declaration -> declare_int .

    newline         reduce using rule 11 (declaration -> declare_int .)
    $end            reduce using rule 11 (declaration -> declare_int .)


state 6

    (12) declaration -> declare_float .

    newline         reduce using rule 12 (declaration -> declare_float .)
    $end            reduce using rule 12 (declaration -> declare_float .)


state 7

    (13) declaration -> declare_string .

    newline         reduce using rule 13 (declaration -> declare_string .)
    $end            reduce using rule 13 (declaration -> declare_string .)


state 8

    (5) echo -> ECHO . expression
    (6) expression -> . INT
    (7) expression -> . FLOAT
    (8) expression -> . STRING
    (9) expression -> . SEQUENCE
    (10) expression -> . EVALUATE

    INT             shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    SEQUENCE        shift and go to state 15
    EVALUATE        shift and go to state 16

    expression                     shift and go to state 11

state 9

    (14) declare_int -> SEQUENCE . = INT
    (15) declare_float -> SEQUENCE . = FLOAT
    (16) declare_string -> SEQUENCE . = STRING

    =               shift and go to state 17


state 10

    (2) programme -> statement newline . programme
    (1) programme -> . statement
    (2) programme -> . statement newline programme
    (3) statement -> . declaration
    (4) statement -> . echo
    (11) declaration -> . declare_int
    (12) declaration -> . declare_float
    (13) declaration -> . declare_string
    (5) echo -> . ECHO expression
    (14) declare_int -> . SEQUENCE = INT
    (15) declare_float -> . SEQUENCE = FLOAT
    (16) declare_string -> . SEQUENCE = STRING

    ECHO            shift and go to state 8
    SEQUENCE        shift and go to state 9

    statement                      shift and go to state 2
    programme                      shift and go to state 18
    declaration                    shift and go to state 3
    echo                           shift and go to state 4
    declare_int                    shift and go to state 5
    declare_float                  shift and go to state 6
    declare_string                 shift and go to state 7

state 11

    (5) echo -> ECHO expression .

    newline         reduce using rule 5 (echo -> ECHO expression .)
    $end            reduce using rule 5 (echo -> ECHO expression .)


state 12

    (6) expression -> INT .

    newline         reduce using rule 6 (expression -> INT .)
    $end            reduce using rule 6 (expression -> INT .)


state 13

    (7) expression -> FLOAT .

    newline         reduce using rule 7 (expression -> FLOAT .)
    $end            reduce using rule 7 (expression -> FLOAT .)


state 14

    (8) expression -> STRING .

    newline         reduce using rule 8 (expression -> STRING .)
    $end            reduce using rule 8 (expression -> STRING .)


state 15

    (9) expression -> SEQUENCE .

    newline         reduce using rule 9 (expression -> SEQUENCE .)
    $end            reduce using rule 9 (expression -> SEQUENCE .)


state 16

    (10) expression -> EVALUATE .

    newline         reduce using rule 10 (expression -> EVALUATE .)
    $end            reduce using rule 10 (expression -> EVALUATE .)


state 17

    (14) declare_int -> SEQUENCE = . INT
    (15) declare_float -> SEQUENCE = . FLOAT
    (16) declare_string -> SEQUENCE = . STRING

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21


state 18

    (2) programme -> statement newline programme .

    $end            reduce using rule 2 (programme -> statement newline programme .)


state 19

    (14) declare_int -> SEQUENCE = INT .

    newline         reduce using rule 14 (declare_int -> SEQUENCE = INT .)
    $end            reduce using rule 14 (declare_int -> SEQUENCE = INT .)


state 20

    (15) declare_float -> SEQUENCE = FLOAT .

    newline         reduce using rule 15 (declare_float -> SEQUENCE = FLOAT .)
    $end            reduce using rule 15 (declare_float -> SEQUENCE = FLOAT .)


state 21

    (16) declare_string -> SEQUENCE = STRING .

    newline         reduce using rule 16 (declare_string -> SEQUENCE = STRING .)
    $end            reduce using rule 16 (declare_string -> SEQUENCE = STRING .)

