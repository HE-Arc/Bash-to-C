Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    HEADER

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement newline
Rule 2     programme -> statement newline programme
Rule 3     statement -> affectation
Rule 4     affectation -> SET_VARIABLE = expression
Rule 5     statement -> ECHO expression
Rule 6     expression -> GET_VARIABLE
Rule 7     expression -> FLOAT
Rule 8     expression -> INT
Rule 9     expression -> STRING
Rule 10    expression -> $ ( ( expression ADD_OP expression ) )
Rule 11    expression -> $ ( ( expression MUL_OP expression ) )
Rule 12    expression -> expression EQ_CMP expression
Rule 13    expression -> expression NE_CMP expression
Rule 14    expression -> expression LT_CMP expression
Rule 15    block -> statement newline
Rule 16    block -> statement newline block
Rule 17    statement -> IF [ expression ] newline THEN newline block FI
Rule 18    statement -> IF [ expression ] newline THEN newline block ELSE newline block FI
Rule 19    statement -> WHILE [ expression ] ; DO newline block DONE
Rule 20    statement -> UNTIL [ expression ] ; DO newline block DONE

Terminals, with rules where they appear

$                    : 10 11
(                    : 10 10 11 11
)                    : 10 10 11 11
;                    : 19 20
=                    : 4
ADD_OP               : 10
DO                   : 19 20
DONE                 : 19 20
ECHO                 : 5
ELSE                 : 18
EQ_CMP               : 12
FI                   : 17 18
FLOAT                : 7
GET_VARIABLE         : 6
HEADER               : 
IF                   : 17 18
INT                  : 8
LT_CMP               : 14
MUL_OP               : 11
NE_CMP               : 13
SET_VARIABLE         : 4
STRING               : 9
THEN                 : 17 18
UNTIL                : 20
WHILE                : 19
[                    : 17 18 19 20
]                    : 17 18 19 20
error                : 
newline              : 1 2 15 16 17 17 18 18 18 19 20

Nonterminals, with rules where they appear

affectation          : 3
block                : 16 17 18 18 19 20
expression           : 4 5 10 10 11 11 12 12 13 13 14 14 17 18 19 20
programme            : 2 0
statement            : 1 2 15 16

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    affectation                    shift and go to state 3

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . newline
    (2) programme -> statement . newline programme

    newline         shift and go to state 9


state 3

    (3) statement -> affectation .

    newline         reduce using rule 3 (statement -> affectation .)


state 4

    (5) statement -> ECHO . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 10

state 5

    (17) statement -> IF . [ expression ] newline THEN newline block FI
    (18) statement -> IF . [ expression ] newline THEN newline block ELSE newline block FI

    [               shift and go to state 16


state 6

    (19) statement -> WHILE . [ expression ] ; DO newline block DONE

    [               shift and go to state 17


state 7

    (20) statement -> UNTIL . [ expression ] ; DO newline block DONE

    [               shift and go to state 18


state 8

    (4) affectation -> SET_VARIABLE . = expression

    =               shift and go to state 19


state 9

    (1) programme -> statement newline .
    (2) programme -> statement newline . programme
    (1) programme -> . statement newline
    (2) programme -> . statement newline programme
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 1 (programme -> statement newline .)
    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    statement                      shift and go to state 2
    programme                      shift and go to state 20
    affectation                    shift and go to state 3

state 10

    (5) statement -> ECHO expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    newline         reduce using rule 5 (statement -> ECHO expression .)
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 11

    (6) expression -> GET_VARIABLE .

    EQ_CMP          reduce using rule 6 (expression -> GET_VARIABLE .)
    NE_CMP          reduce using rule 6 (expression -> GET_VARIABLE .)
    LT_CMP          reduce using rule 6 (expression -> GET_VARIABLE .)
    newline         reduce using rule 6 (expression -> GET_VARIABLE .)
    ]               reduce using rule 6 (expression -> GET_VARIABLE .)
    ADD_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    MUL_OP          reduce using rule 6 (expression -> GET_VARIABLE .)
    )               reduce using rule 6 (expression -> GET_VARIABLE .)


state 12

    (7) expression -> FLOAT .

    EQ_CMP          reduce using rule 7 (expression -> FLOAT .)
    NE_CMP          reduce using rule 7 (expression -> FLOAT .)
    LT_CMP          reduce using rule 7 (expression -> FLOAT .)
    newline         reduce using rule 7 (expression -> FLOAT .)
    ]               reduce using rule 7 (expression -> FLOAT .)
    ADD_OP          reduce using rule 7 (expression -> FLOAT .)
    MUL_OP          reduce using rule 7 (expression -> FLOAT .)
    )               reduce using rule 7 (expression -> FLOAT .)


state 13

    (8) expression -> INT .

    EQ_CMP          reduce using rule 8 (expression -> INT .)
    NE_CMP          reduce using rule 8 (expression -> INT .)
    LT_CMP          reduce using rule 8 (expression -> INT .)
    newline         reduce using rule 8 (expression -> INT .)
    ]               reduce using rule 8 (expression -> INT .)
    ADD_OP          reduce using rule 8 (expression -> INT .)
    MUL_OP          reduce using rule 8 (expression -> INT .)
    )               reduce using rule 8 (expression -> INT .)


state 14

    (9) expression -> STRING .

    EQ_CMP          reduce using rule 9 (expression -> STRING .)
    NE_CMP          reduce using rule 9 (expression -> STRING .)
    LT_CMP          reduce using rule 9 (expression -> STRING .)
    newline         reduce using rule 9 (expression -> STRING .)
    ]               reduce using rule 9 (expression -> STRING .)
    ADD_OP          reduce using rule 9 (expression -> STRING .)
    MUL_OP          reduce using rule 9 (expression -> STRING .)
    )               reduce using rule 9 (expression -> STRING .)


state 15

    (10) expression -> $ . ( ( expression ADD_OP expression ) )
    (11) expression -> $ . ( ( expression MUL_OP expression ) )

    (               shift and go to state 24


state 16

    (17) statement -> IF [ . expression ] newline THEN newline block FI
    (18) statement -> IF [ . expression ] newline THEN newline block ELSE newline block FI
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 25

state 17

    (19) statement -> WHILE [ . expression ] ; DO newline block DONE
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 26

state 18

    (20) statement -> UNTIL [ . expression ] ; DO newline block DONE
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 27

state 19

    (4) affectation -> SET_VARIABLE = . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 28

state 20

    (2) programme -> statement newline programme .

    $end            reduce using rule 2 (programme -> statement newline programme .)


state 21

    (12) expression -> expression EQ_CMP . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 29

state 22

    (13) expression -> expression NE_CMP . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 30

state 23

    (14) expression -> expression LT_CMP . expression
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 31

state 24

    (10) expression -> $ ( . ( expression ADD_OP expression ) )
    (11) expression -> $ ( . ( expression MUL_OP expression ) )

    (               shift and go to state 32


state 25

    (17) statement -> IF [ expression . ] newline THEN newline block FI
    (18) statement -> IF [ expression . ] newline THEN newline block ELSE newline block FI
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    ]               shift and go to state 33
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 26

    (19) statement -> WHILE [ expression . ] ; DO newline block DONE
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    ]               shift and go to state 34
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 27

    (20) statement -> UNTIL [ expression . ] ; DO newline block DONE
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    ]               shift and go to state 35
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 28

    (4) affectation -> SET_VARIABLE = expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    newline         reduce using rule 4 (affectation -> SET_VARIABLE = expression .)
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 29

    (12) expression -> expression EQ_CMP expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 12 (expression -> expression EQ_CMP expression .)
    ]               reduce using rule 12 (expression -> expression EQ_CMP expression .)
    ADD_OP          reduce using rule 12 (expression -> expression EQ_CMP expression .)
    MUL_OP          reduce using rule 12 (expression -> expression EQ_CMP expression .)
    )               reduce using rule 12 (expression -> expression EQ_CMP expression .)
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23

  ! EQ_CMP          [ reduce using rule 12 (expression -> expression EQ_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 12 (expression -> expression EQ_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 12 (expression -> expression EQ_CMP expression .) ]


state 30

    (13) expression -> expression NE_CMP expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 13 (expression -> expression NE_CMP expression .)
    ]               reduce using rule 13 (expression -> expression NE_CMP expression .)
    ADD_OP          reduce using rule 13 (expression -> expression NE_CMP expression .)
    MUL_OP          reduce using rule 13 (expression -> expression NE_CMP expression .)
    )               reduce using rule 13 (expression -> expression NE_CMP expression .)
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23

  ! EQ_CMP          [ reduce using rule 13 (expression -> expression NE_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 13 (expression -> expression NE_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 13 (expression -> expression NE_CMP expression .) ]


state 31

    (14) expression -> expression LT_CMP expression .
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

  ! shift/reduce conflict for EQ_CMP resolved as shift
  ! shift/reduce conflict for NE_CMP resolved as shift
  ! shift/reduce conflict for LT_CMP resolved as shift
    newline         reduce using rule 14 (expression -> expression LT_CMP expression .)
    ]               reduce using rule 14 (expression -> expression LT_CMP expression .)
    ADD_OP          reduce using rule 14 (expression -> expression LT_CMP expression .)
    MUL_OP          reduce using rule 14 (expression -> expression LT_CMP expression .)
    )               reduce using rule 14 (expression -> expression LT_CMP expression .)
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23

  ! EQ_CMP          [ reduce using rule 14 (expression -> expression LT_CMP expression .) ]
  ! NE_CMP          [ reduce using rule 14 (expression -> expression LT_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 14 (expression -> expression LT_CMP expression .) ]


state 32

    (10) expression -> $ ( ( . expression ADD_OP expression ) )
    (11) expression -> $ ( ( . expression MUL_OP expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 36

state 33

    (17) statement -> IF [ expression ] . newline THEN newline block FI
    (18) statement -> IF [ expression ] . newline THEN newline block ELSE newline block FI

    newline         shift and go to state 37


state 34

    (19) statement -> WHILE [ expression ] . ; DO newline block DONE

    ;               shift and go to state 38


state 35

    (20) statement -> UNTIL [ expression ] . ; DO newline block DONE

    ;               shift and go to state 39


state 36

    (10) expression -> $ ( ( expression . ADD_OP expression ) )
    (11) expression -> $ ( ( expression . MUL_OP expression ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    ADD_OP          shift and go to state 40
    MUL_OP          shift and go to state 41
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 37

    (17) statement -> IF [ expression ] newline . THEN newline block FI
    (18) statement -> IF [ expression ] newline . THEN newline block ELSE newline block FI

    THEN            shift and go to state 42


state 38

    (19) statement -> WHILE [ expression ] ; . DO newline block DONE

    DO              shift and go to state 43


state 39

    (20) statement -> UNTIL [ expression ] ; . DO newline block DONE

    DO              shift and go to state 44


state 40

    (10) expression -> $ ( ( expression ADD_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 45

state 41

    (11) expression -> $ ( ( expression MUL_OP . expression ) )
    (6) expression -> . GET_VARIABLE
    (7) expression -> . FLOAT
    (8) expression -> . INT
    (9) expression -> . STRING
    (10) expression -> . $ ( ( expression ADD_OP expression ) )
    (11) expression -> . $ ( ( expression MUL_OP expression ) )
    (12) expression -> . expression EQ_CMP expression
    (13) expression -> . expression NE_CMP expression
    (14) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 11
    FLOAT           shift and go to state 12
    INT             shift and go to state 13
    STRING          shift and go to state 14
    $               shift and go to state 15

    expression                     shift and go to state 46

state 42

    (17) statement -> IF [ expression ] newline THEN . newline block FI
    (18) statement -> IF [ expression ] newline THEN . newline block ELSE newline block FI

    newline         shift and go to state 47


state 43

    (19) statement -> WHILE [ expression ] ; DO . newline block DONE

    newline         shift and go to state 48


state 44

    (20) statement -> UNTIL [ expression ] ; DO . newline block DONE

    newline         shift and go to state 49


state 45

    (10) expression -> $ ( ( expression ADD_OP expression . ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    )               shift and go to state 50
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 46

    (11) expression -> $ ( ( expression MUL_OP expression . ) )
    (12) expression -> expression . EQ_CMP expression
    (13) expression -> expression . NE_CMP expression
    (14) expression -> expression . LT_CMP expression

    )               shift and go to state 51
    EQ_CMP          shift and go to state 21
    NE_CMP          shift and go to state 22
    LT_CMP          shift and go to state 23


state 47

    (17) statement -> IF [ expression ] newline THEN newline . block FI
    (18) statement -> IF [ expression ] newline THEN newline . block ELSE newline block FI
    (15) block -> . statement newline
    (16) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    block                          shift and go to state 52
    statement                      shift and go to state 53
    affectation                    shift and go to state 3

state 48

    (19) statement -> WHILE [ expression ] ; DO newline . block DONE
    (15) block -> . statement newline
    (16) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    block                          shift and go to state 54
    statement                      shift and go to state 53
    affectation                    shift and go to state 3

state 49

    (20) statement -> UNTIL [ expression ] ; DO newline . block DONE
    (15) block -> . statement newline
    (16) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    block                          shift and go to state 55
    statement                      shift and go to state 53
    affectation                    shift and go to state 3

state 50

    (10) expression -> $ ( ( expression ADD_OP expression ) . )

    )               shift and go to state 56


state 51

    (11) expression -> $ ( ( expression MUL_OP expression ) . )

    )               shift and go to state 57


state 52

    (17) statement -> IF [ expression ] newline THEN newline block . FI
    (18) statement -> IF [ expression ] newline THEN newline block . ELSE newline block FI

    FI              shift and go to state 58
    ELSE            shift and go to state 59


state 53

    (15) block -> statement . newline
    (16) block -> statement . newline block

    newline         shift and go to state 60


state 54

    (19) statement -> WHILE [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 61


state 55

    (20) statement -> UNTIL [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 62


state 56

    (10) expression -> $ ( ( expression ADD_OP expression ) ) .

    EQ_CMP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    NE_CMP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    LT_CMP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    newline         reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ]               reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ADD_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    MUL_OP          reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    )               reduce using rule 10 (expression -> $ ( ( expression ADD_OP expression ) ) .)


state 57

    (11) expression -> $ ( ( expression MUL_OP expression ) ) .

    EQ_CMP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    NE_CMP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    LT_CMP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    newline         reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ]               reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ADD_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    MUL_OP          reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    )               reduce using rule 11 (expression -> $ ( ( expression MUL_OP expression ) ) .)


state 58

    (17) statement -> IF [ expression ] newline THEN newline block FI .

    newline         reduce using rule 17 (statement -> IF [ expression ] newline THEN newline block FI .)


state 59

    (18) statement -> IF [ expression ] newline THEN newline block ELSE . newline block FI

    newline         shift and go to state 63


state 60

    (15) block -> statement newline .
    (16) block -> statement newline . block
    (15) block -> . statement newline
    (16) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    FI              reduce using rule 15 (block -> statement newline .)
    ELSE            reduce using rule 15 (block -> statement newline .)
    DONE            reduce using rule 15 (block -> statement newline .)
    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    statement                      shift and go to state 53
    block                          shift and go to state 64
    affectation                    shift and go to state 3

state 61

    (19) statement -> WHILE [ expression ] ; DO newline block DONE .

    newline         reduce using rule 19 (statement -> WHILE [ expression ] ; DO newline block DONE .)


state 62

    (20) statement -> UNTIL [ expression ] ; DO newline block DONE .

    newline         reduce using rule 20 (statement -> UNTIL [ expression ] ; DO newline block DONE .)


state 63

    (18) statement -> IF [ expression ] newline THEN newline block ELSE newline . block FI
    (15) block -> . statement newline
    (16) block -> . statement newline block
    (3) statement -> . affectation
    (5) statement -> . ECHO expression
    (17) statement -> . IF [ expression ] newline THEN newline block FI
    (18) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (19) statement -> . WHILE [ expression ] ; DO newline block DONE
    (20) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (4) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 4
    IF              shift and go to state 5
    WHILE           shift and go to state 6
    UNTIL           shift and go to state 7
    SET_VARIABLE    shift and go to state 8

    block                          shift and go to state 65
    statement                      shift and go to state 53
    affectation                    shift and go to state 3

state 64

    (16) block -> statement newline block .

    FI              reduce using rule 16 (block -> statement newline block .)
    ELSE            reduce using rule 16 (block -> statement newline block .)
    DONE            reduce using rule 16 (block -> statement newline block .)


state 65

    (18) statement -> IF [ expression ] newline THEN newline block ELSE newline block . FI

    FI              shift and go to state 66


state 66

    (18) statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .

    newline         reduce using rule 18 (statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ_CMP in state 29 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 29 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 29 resolved as shift
WARNING: shift/reduce conflict for EQ_CMP in state 30 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 30 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 30 resolved as shift
WARNING: shift/reduce conflict for EQ_CMP in state 31 resolved as shift
WARNING: shift/reduce conflict for NE_CMP in state 31 resolved as shift
WARNING: shift/reduce conflict for LT_CMP in state 31 resolved as shift
