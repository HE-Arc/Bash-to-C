Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> HEADER newline statement newline
Rule 2     programme -> statement newline
Rule 3     programme -> HEADER newline statement newline programme
Rule 4     programme -> statement newline programme
Rule 5     statement -> affectation
Rule 6     affectation -> SET_VARIABLE = expression
Rule 7     statement -> ECHO expression
Rule 8     expression -> GET_VARIABLE
Rule 9     expression -> FLOAT
Rule 10    expression -> INT
Rule 11    expression -> STRING
Rule 12    expression -> $ ( ( expression ADD_OP expression ) )
Rule 13    expression -> $ ( ( expression MUL_OP expression ) )
Rule 14    expression -> expression EQ_CMP expression
Rule 15    expression -> expression NE_CMP expression
Rule 16    expression -> expression LT_CMP expression
Rule 17    block -> statement newline
Rule 18    block -> statement newline block
Rule 19    statement -> IF [ expression ] newline THEN newline block FI
Rule 20    statement -> IF [ expression ] newline THEN newline block ELSE newline block FI
Rule 21    statement -> WHILE [ expression ] ; DO newline block DONE
Rule 22    statement -> UNTIL [ expression ] ; DO newline block DONE
Rule 23    statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE

Terminals, with rules where they appear

$                    : 12 13
(                    : 12 12 13 13
)                    : 12 12 13 13
.                    : 23 23
;                    : 21 22 23
=                    : 6
ADD_OP               : 12
DO                   : 21 22 23
DONE                 : 21 22 23
ECHO                 : 7
ELSE                 : 20
EQ_CMP               : 14
FI                   : 19 20
FLOAT                : 9
FOR                  : 23
GET_VARIABLE         : 8
HEADER               : 1 3
IF                   : 19 20
IN                   : 23
INT                  : 10 23 23
LT_CMP               : 16
MUL_OP               : 13
NE_CMP               : 15
SET_VARIABLE         : 6 23
STRING               : 11
THEN                 : 19 20
UNTIL                : 22
WHILE                : 21
[                    : 19 20 21 22
]                    : 19 20 21 22
error                : 
newline              : 1 1 2 3 3 4 17 18 19 19 20 20 20 21 22 23
{                    : 23
}                    : 23

Nonterminals, with rules where they appear

affectation          : 5
block                : 18 19 20 20 21 22 23
expression           : 6 7 12 12 13 13 14 14 15 15 16 16 19 20 21 22
programme            : 3 4 0
statement            : 1 2 3 4 17 18

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    programme                      shift and go to state 1
    statement                      shift and go to state 3
    affectation                    shift and go to state 4

state 1

    (0) S' -> programme .



state 2

    (1) programme -> HEADER . newline statement newline
    (3) programme -> HEADER . newline statement newline programme

    newline         shift and go to state 11


state 3

    (2) programme -> statement . newline
    (4) programme -> statement . newline programme

    newline         shift and go to state 12


state 4

    (5) statement -> affectation .

    newline         reduce using rule 5 (statement -> affectation .)


state 5

    (7) statement -> ECHO . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 13

state 6

    (19) statement -> IF . [ expression ] newline THEN newline block FI
    (20) statement -> IF . [ expression ] newline THEN newline block ELSE newline block FI

    [               shift and go to state 19


state 7

    (21) statement -> WHILE . [ expression ] ; DO newline block DONE

    [               shift and go to state 20


state 8

    (22) statement -> UNTIL . [ expression ] ; DO newline block DONE

    [               shift and go to state 21


state 9

    (23) statement -> FOR . SET_VARIABLE IN { INT . . INT } ; DO newline block DONE

    SET_VARIABLE    shift and go to state 22


state 10

    (6) affectation -> SET_VARIABLE . = expression

    =               shift and go to state 23


state 11

    (1) programme -> HEADER newline . statement newline
    (3) programme -> HEADER newline . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    statement                      shift and go to state 24
    affectation                    shift and go to state 4

state 12

    (2) programme -> statement newline .
    (4) programme -> statement newline . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 2 (programme -> statement newline .)
    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    statement                      shift and go to state 3
    programme                      shift and go to state 25
    affectation                    shift and go to state 4

state 13

    (7) statement -> ECHO expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    newline         reduce using rule 7 (statement -> ECHO expression .)
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 14

    (8) expression -> GET_VARIABLE .

    EQ_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    NE_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    LT_CMP          reduce using rule 8 (expression -> GET_VARIABLE .)
    newline         reduce using rule 8 (expression -> GET_VARIABLE .)
    ]               reduce using rule 8 (expression -> GET_VARIABLE .)
    ADD_OP          reduce using rule 8 (expression -> GET_VARIABLE .)
    MUL_OP          reduce using rule 8 (expression -> GET_VARIABLE .)
    )               reduce using rule 8 (expression -> GET_VARIABLE .)


state 15

    (9) expression -> FLOAT .

    EQ_CMP          reduce using rule 9 (expression -> FLOAT .)
    NE_CMP          reduce using rule 9 (expression -> FLOAT .)
    LT_CMP          reduce using rule 9 (expression -> FLOAT .)
    newline         reduce using rule 9 (expression -> FLOAT .)
    ]               reduce using rule 9 (expression -> FLOAT .)
    ADD_OP          reduce using rule 9 (expression -> FLOAT .)
    MUL_OP          reduce using rule 9 (expression -> FLOAT .)
    )               reduce using rule 9 (expression -> FLOAT .)


state 16

    (10) expression -> INT .

    EQ_CMP          reduce using rule 10 (expression -> INT .)
    NE_CMP          reduce using rule 10 (expression -> INT .)
    LT_CMP          reduce using rule 10 (expression -> INT .)
    newline         reduce using rule 10 (expression -> INT .)
    ]               reduce using rule 10 (expression -> INT .)
    ADD_OP          reduce using rule 10 (expression -> INT .)
    MUL_OP          reduce using rule 10 (expression -> INT .)
    )               reduce using rule 10 (expression -> INT .)


state 17

    (11) expression -> STRING .

    EQ_CMP          reduce using rule 11 (expression -> STRING .)
    NE_CMP          reduce using rule 11 (expression -> STRING .)
    LT_CMP          reduce using rule 11 (expression -> STRING .)
    newline         reduce using rule 11 (expression -> STRING .)
    ]               reduce using rule 11 (expression -> STRING .)
    ADD_OP          reduce using rule 11 (expression -> STRING .)
    MUL_OP          reduce using rule 11 (expression -> STRING .)
    )               reduce using rule 11 (expression -> STRING .)


state 18

    (12) expression -> $ . ( ( expression ADD_OP expression ) )
    (13) expression -> $ . ( ( expression MUL_OP expression ) )

    (               shift and go to state 29


state 19

    (19) statement -> IF [ . expression ] newline THEN newline block FI
    (20) statement -> IF [ . expression ] newline THEN newline block ELSE newline block FI
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 30

state 20

    (21) statement -> WHILE [ . expression ] ; DO newline block DONE
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 31

state 21

    (22) statement -> UNTIL [ . expression ] ; DO newline block DONE
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 32

state 22

    (23) statement -> FOR SET_VARIABLE . IN { INT . . INT } ; DO newline block DONE

    IN              shift and go to state 33


state 23

    (6) affectation -> SET_VARIABLE = . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 34

state 24

    (1) programme -> HEADER newline statement . newline
    (3) programme -> HEADER newline statement . newline programme

    newline         shift and go to state 35


state 25

    (4) programme -> statement newline programme .

    $end            reduce using rule 4 (programme -> statement newline programme .)


state 26

    (14) expression -> expression EQ_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 36

state 27

    (15) expression -> expression NE_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 37

state 28

    (16) expression -> expression LT_CMP . expression
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 38

state 29

    (12) expression -> $ ( . ( expression ADD_OP expression ) )
    (13) expression -> $ ( . ( expression MUL_OP expression ) )

    (               shift and go to state 39


state 30

    (19) statement -> IF [ expression . ] newline THEN newline block FI
    (20) statement -> IF [ expression . ] newline THEN newline block ELSE newline block FI
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 40
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 31

    (21) statement -> WHILE [ expression . ] ; DO newline block DONE
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 41
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 32

    (22) statement -> UNTIL [ expression . ] ; DO newline block DONE
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ]               shift and go to state 42
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 33

    (23) statement -> FOR SET_VARIABLE IN . { INT . . INT } ; DO newline block DONE

    {               shift and go to state 43


state 34

    (6) affectation -> SET_VARIABLE = expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    newline         reduce using rule 6 (affectation -> SET_VARIABLE = expression .)
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 35

    (1) programme -> HEADER newline statement newline .
    (3) programme -> HEADER newline statement newline . programme
    (1) programme -> . HEADER newline statement newline
    (2) programme -> . statement newline
    (3) programme -> . HEADER newline statement newline programme
    (4) programme -> . statement newline programme
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    $end            reduce using rule 1 (programme -> HEADER newline statement newline .)
    HEADER          shift and go to state 2
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    statement                      shift and go to state 3
    programme                      shift and go to state 44
    affectation                    shift and go to state 4

state 36

    (14) expression -> expression EQ_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    EQ_CMP          reduce using rule 14 (expression -> expression EQ_CMP expression .)
    newline         reduce using rule 14 (expression -> expression EQ_CMP expression .)
    ]               reduce using rule 14 (expression -> expression EQ_CMP expression .)
    ADD_OP          reduce using rule 14 (expression -> expression EQ_CMP expression .)
    MUL_OP          reduce using rule 14 (expression -> expression EQ_CMP expression .)
    )               reduce using rule 14 (expression -> expression EQ_CMP expression .)
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28

  ! NE_CMP          [ reduce using rule 14 (expression -> expression EQ_CMP expression .) ]
  ! LT_CMP          [ reduce using rule 14 (expression -> expression EQ_CMP expression .) ]
  ! EQ_CMP          [ shift and go to state 26 ]


state 37

    (15) expression -> expression NE_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    EQ_CMP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    NE_CMP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    newline         reduce using rule 15 (expression -> expression NE_CMP expression .)
    ]               reduce using rule 15 (expression -> expression NE_CMP expression .)
    ADD_OP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    MUL_OP          reduce using rule 15 (expression -> expression NE_CMP expression .)
    )               reduce using rule 15 (expression -> expression NE_CMP expression .)
    LT_CMP          shift and go to state 28

  ! LT_CMP          [ reduce using rule 15 (expression -> expression NE_CMP expression .) ]
  ! EQ_CMP          [ shift and go to state 26 ]
  ! NE_CMP          [ shift and go to state 27 ]


state 38

    (16) expression -> expression LT_CMP expression .
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    EQ_CMP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    NE_CMP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    LT_CMP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    newline         reduce using rule 16 (expression -> expression LT_CMP expression .)
    ]               reduce using rule 16 (expression -> expression LT_CMP expression .)
    ADD_OP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    MUL_OP          reduce using rule 16 (expression -> expression LT_CMP expression .)
    )               reduce using rule 16 (expression -> expression LT_CMP expression .)

  ! EQ_CMP          [ shift and go to state 26 ]
  ! NE_CMP          [ shift and go to state 27 ]
  ! LT_CMP          [ shift and go to state 28 ]


state 39

    (12) expression -> $ ( ( . expression ADD_OP expression ) )
    (13) expression -> $ ( ( . expression MUL_OP expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 45

state 40

    (19) statement -> IF [ expression ] . newline THEN newline block FI
    (20) statement -> IF [ expression ] . newline THEN newline block ELSE newline block FI

    newline         shift and go to state 46


state 41

    (21) statement -> WHILE [ expression ] . ; DO newline block DONE

    ;               shift and go to state 47


state 42

    (22) statement -> UNTIL [ expression ] . ; DO newline block DONE

    ;               shift and go to state 48


state 43

    (23) statement -> FOR SET_VARIABLE IN { . INT . . INT } ; DO newline block DONE

    INT             shift and go to state 49


state 44

    (3) programme -> HEADER newline statement newline programme .

    $end            reduce using rule 3 (programme -> HEADER newline statement newline programme .)


state 45

    (12) expression -> $ ( ( expression . ADD_OP expression ) )
    (13) expression -> $ ( ( expression . MUL_OP expression ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    ADD_OP          shift and go to state 50
    MUL_OP          shift and go to state 51
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 46

    (19) statement -> IF [ expression ] newline . THEN newline block FI
    (20) statement -> IF [ expression ] newline . THEN newline block ELSE newline block FI

    THEN            shift and go to state 52


state 47

    (21) statement -> WHILE [ expression ] ; . DO newline block DONE

    DO              shift and go to state 53


state 48

    (22) statement -> UNTIL [ expression ] ; . DO newline block DONE

    DO              shift and go to state 54


state 49

    (23) statement -> FOR SET_VARIABLE IN { INT . . . INT } ; DO newline block DONE

    .               shift and go to state 55


state 50

    (12) expression -> $ ( ( expression ADD_OP . expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 56

state 51

    (13) expression -> $ ( ( expression MUL_OP . expression ) )
    (8) expression -> . GET_VARIABLE
    (9) expression -> . FLOAT
    (10) expression -> . INT
    (11) expression -> . STRING
    (12) expression -> . $ ( ( expression ADD_OP expression ) )
    (13) expression -> . $ ( ( expression MUL_OP expression ) )
    (14) expression -> . expression EQ_CMP expression
    (15) expression -> . expression NE_CMP expression
    (16) expression -> . expression LT_CMP expression

    GET_VARIABLE    shift and go to state 14
    FLOAT           shift and go to state 15
    INT             shift and go to state 16
    STRING          shift and go to state 17
    $               shift and go to state 18

    expression                     shift and go to state 57

state 52

    (19) statement -> IF [ expression ] newline THEN . newline block FI
    (20) statement -> IF [ expression ] newline THEN . newline block ELSE newline block FI

    newline         shift and go to state 58


state 53

    (21) statement -> WHILE [ expression ] ; DO . newline block DONE

    newline         shift and go to state 59


state 54

    (22) statement -> UNTIL [ expression ] ; DO . newline block DONE

    newline         shift and go to state 60


state 55

    (23) statement -> FOR SET_VARIABLE IN { INT . . . INT } ; DO newline block DONE

    .               shift and go to state 61


state 56

    (12) expression -> $ ( ( expression ADD_OP expression . ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    )               shift and go to state 62
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 57

    (13) expression -> $ ( ( expression MUL_OP expression . ) )
    (14) expression -> expression . EQ_CMP expression
    (15) expression -> expression . NE_CMP expression
    (16) expression -> expression . LT_CMP expression

    )               shift and go to state 63
    EQ_CMP          shift and go to state 26
    NE_CMP          shift and go to state 27
    LT_CMP          shift and go to state 28


state 58

    (19) statement -> IF [ expression ] newline THEN newline . block FI
    (20) statement -> IF [ expression ] newline THEN newline . block ELSE newline block FI
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    block                          shift and go to state 64
    statement                      shift and go to state 65
    affectation                    shift and go to state 4

state 59

    (21) statement -> WHILE [ expression ] ; DO newline . block DONE
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    block                          shift and go to state 66
    statement                      shift and go to state 65
    affectation                    shift and go to state 4

state 60

    (22) statement -> UNTIL [ expression ] ; DO newline . block DONE
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    block                          shift and go to state 67
    statement                      shift and go to state 65
    affectation                    shift and go to state 4

state 61

    (23) statement -> FOR SET_VARIABLE IN { INT . . . INT } ; DO newline block DONE

    INT             shift and go to state 68


state 62

    (12) expression -> $ ( ( expression ADD_OP expression ) . )

    )               shift and go to state 69


state 63

    (13) expression -> $ ( ( expression MUL_OP expression ) . )

    )               shift and go to state 70


state 64

    (19) statement -> IF [ expression ] newline THEN newline block . FI
    (20) statement -> IF [ expression ] newline THEN newline block . ELSE newline block FI

    FI              shift and go to state 71
    ELSE            shift and go to state 72


state 65

    (17) block -> statement . newline
    (18) block -> statement . newline block

    newline         shift and go to state 73


state 66

    (21) statement -> WHILE [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 74


state 67

    (22) statement -> UNTIL [ expression ] ; DO newline block . DONE

    DONE            shift and go to state 75


state 68

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT . } ; DO newline block DONE

    }               shift and go to state 76


state 69

    (12) expression -> $ ( ( expression ADD_OP expression ) ) .

    EQ_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    NE_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    LT_CMP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    newline         reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ]               reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    ADD_OP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    MUL_OP          reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)
    )               reduce using rule 12 (expression -> $ ( ( expression ADD_OP expression ) ) .)


state 70

    (13) expression -> $ ( ( expression MUL_OP expression ) ) .

    EQ_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    NE_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    LT_CMP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    newline         reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ]               reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    ADD_OP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    MUL_OP          reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)
    )               reduce using rule 13 (expression -> $ ( ( expression MUL_OP expression ) ) .)


state 71

    (19) statement -> IF [ expression ] newline THEN newline block FI .

    newline         reduce using rule 19 (statement -> IF [ expression ] newline THEN newline block FI .)


state 72

    (20) statement -> IF [ expression ] newline THEN newline block ELSE . newline block FI

    newline         shift and go to state 77


state 73

    (17) block -> statement newline .
    (18) block -> statement newline . block
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    FI              reduce using rule 17 (block -> statement newline .)
    ELSE            reduce using rule 17 (block -> statement newline .)
    DONE            reduce using rule 17 (block -> statement newline .)
    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    statement                      shift and go to state 65
    block                          shift and go to state 78
    affectation                    shift and go to state 4

state 74

    (21) statement -> WHILE [ expression ] ; DO newline block DONE .

    newline         reduce using rule 21 (statement -> WHILE [ expression ] ; DO newline block DONE .)


state 75

    (22) statement -> UNTIL [ expression ] ; DO newline block DONE .

    newline         reduce using rule 22 (statement -> UNTIL [ expression ] ; DO newline block DONE .)


state 76

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } . ; DO newline block DONE

    ;               shift and go to state 79


state 77

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline . block FI
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    block                          shift and go to state 80
    statement                      shift and go to state 65
    affectation                    shift and go to state 4

state 78

    (18) block -> statement newline block .

    FI              reduce using rule 18 (block -> statement newline block .)
    ELSE            reduce using rule 18 (block -> statement newline block .)
    DONE            reduce using rule 18 (block -> statement newline block .)


state 79

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } ; . DO newline block DONE

    DO              shift and go to state 81


state 80

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline block . FI

    FI              shift and go to state 82


state 81

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO . newline block DONE

    newline         shift and go to state 83


state 82

    (20) statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .

    newline         reduce using rule 20 (statement -> IF [ expression ] newline THEN newline block ELSE newline block FI .)


state 83

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO newline . block DONE
    (17) block -> . statement newline
    (18) block -> . statement newline block
    (5) statement -> . affectation
    (7) statement -> . ECHO expression
    (19) statement -> . IF [ expression ] newline THEN newline block FI
    (20) statement -> . IF [ expression ] newline THEN newline block ELSE newline block FI
    (21) statement -> . WHILE [ expression ] ; DO newline block DONE
    (22) statement -> . UNTIL [ expression ] ; DO newline block DONE
    (23) statement -> . FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE
    (6) affectation -> . SET_VARIABLE = expression

    ECHO            shift and go to state 5
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    UNTIL           shift and go to state 8
    FOR             shift and go to state 9
    SET_VARIABLE    shift and go to state 10

    block                          shift and go to state 84
    statement                      shift and go to state 65
    affectation                    shift and go to state 4

state 84

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO newline block . DONE

    DONE            shift and go to state 85


state 85

    (23) statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE .

    newline         reduce using rule 23 (statement -> FOR SET_VARIABLE IN { INT . . INT } ; DO newline block DONE .)

